 Question-1\n",
    "\n",
    "You are given a binary tree. The binary tree is represented using the TreeNode class. Each TreeNode has an integer value and left and right children, represented using the TreeNode class itself. Convert this binary tree into a binary search tree.\n",
    "```\n",
    "Input:\n",
    "\n",
    "        10\n",
    "\n",
    "       /   \\\n",
    "\n",
    "     2      7\n",
    "\n",
    "   /   \\\n",
    "\n",
    " 8      4\n",
    "\n",
    "Output:\n",
    "\n",
    "        8\n",
    "\n",
    "      /   \\\n",
    "\n",
    "    4     10\n",
    "\n",
    "  /   \\\n",
    "\n",
    "2      7\n",
    "```\n",
    "\n",
    "</aside>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2 4 7 8 10 "
     ]
    }
   ],
   "source": [
    "class TreeNode:\n",
    "    def __init__(self, val):\n",
    "        self.val = val\n",
    "        self.left = None\n",
    "        self.right = None\n",
    "\n",
    "\n",
    "def inorderTraversal(node, result):\n",
    "    if node is not None:\n",
    "        inorderTraversal(node.left, result)\n",
    "        result.append(node)\n",
    "        inorderTraversal(node.right, result)\n",
    "\n",
    "\n",
    "def convertToBST(root):\n",
    "    if root is None:\n",
    "        return None\n",
    "\n",
    "    nodes = []\n",
    "    inorderTraversal(root, nodes)\n",
    "    sorted_values = sorted([node.val for node in nodes])\n",
    "\n",
    "    index = 0\n",
    "\n",
    "    def inorderTraversalAndUpdate(node):\n",
    "        nonlocal index\n",
    "        if node is not None:\n",
    "            inorderTraversalAndUpdate(node.left)\n",
    "            node.val = sorted_values[index]\n",
    "            index += 1\n",
    "            inorderTraversalAndUpdate(node.right)\n",
    "\n",
    "    inorderTraversalAndUpdate(root)\n",
    "    return root\n",
    "\n",
    "root = TreeNode(10)\n",
    "root.left = TreeNode(2)\n",
    "root.right = TreeNode(7)\n",
    "root.left.left = TreeNode(8)\n",
    "root.left.right = TreeNode(4)\n",
    "\n",
    "result = convertToBST(root)\n",
    "\n",
    "def inorderTraversal(node):\n",
    "    if node is not None:\n",
    "        inorderTraversal(node.left)\n",
    "        print(node.val, end=\" \")\n",
    "        inorderTraversal(node.right)\n",
    "\n",
    "inorderTraversal(result)\n"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<aside>\n",
    "ðŸ’¡ Question-2:\n",
    "\n",
    "Given a Binary Search Tree with all unique values and two keys. Find the distance between two nodes in BST. The given keys always exist in BST.\n",
    "\n",
    "Example:\n",
    "\n",
    "Consider the following BST:\n",
    "```\n",
    "\n",
    "**Input-1:**\n",
    "\n",
    "n = 9\n",
    "\n",
    "values = [8, 3, 1, 6, 4, 7, 10, 14,13]\n",
    "\n",
    "node-1 = 6\n",
    "\n",
    "node-2 = 14\n",
    "\n",
    "**Output-1:**\n",
    "\n",
    "The distance between the two keys = 4\n",
    "\n",
    "**Input-2:**\n",
    "\n",
    "n = 9\n",
    "\n",
    "values = [8, 3, 1, 6, 4, 7, 10, 14,13]\n",
    "\n",
    "node-1 = 3\n",
    "\n",
    "node-2 = 4\n",
    "\n",
    "**Output-2:**\n",
    "\n",
    "The distance between the two keys = 2\n",
    "```\n",
    "</aside>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The distance between the two keys: 4\n",
      "The distance between the two keys: 2\n"
     ]
    }
   ],
   "source": [
    "class TreeNode:\n",
    "    def __init__(self, val):\n",
    "        self.val = val\n",
    "        self.left = None\n",
    "        self.right = None\n",
    "\n",
    "\n",
    "def constructBST(values):\n",
    "    if not values:\n",
    "        return None\n",
    "\n",
    "    root = TreeNode(values[0])\n",
    "    for val in values[1:]:\n",
    "        insertNode(root, val)\n",
    "\n",
    "    return root\n",
    "\n",
    "\n",
    "def insertNode(root, val):\n",
    "    if root is None:\n",
    "        return TreeNode(val)\n",
    "\n",
    "    if val < root.val:\n",
    "        root.left = insertNode(root.left, val)\n",
    "    else:\n",
    "        root.right = insertNode(root.right, val)\n",
    "\n",
    "    return root\n",
    "\n",
    "\n",
    "def findLCA(root, node1, node2):\n",
    "    if root is None:\n",
    "        return None\n",
    "\n",
    "    if root.val > node1 and root.val > node2:\n",
    "        return findLCA(root.left, node1, node2)\n",
    "    elif root.val < node1 and root.val < node2:\n",
    "        return findLCA(root.right, node1, node2)\n",
    "    else:\n",
    "        return root\n",
    "\n",
    "\n",
    "def findDistance(root, node, distance):\n",
    "    if root is None:\n",
    "        return 0\n",
    "\n",
    "    if root.val == node:\n",
    "        return distance\n",
    "\n",
    "    if root.val > node:\n",
    "        return findDistance(root.left, node, distance + 1)\n",
    "    else:\n",
    "        return findDistance(root.right, node, distance + 1)\n",
    "\n",
    "\n",
    "def distanceBetweenNodes(values, node1, node2):\n",
    "    root = constructBST(values)\n",
    "    lca = findLCA(root, node1, node2)\n",
    "\n",
    "    distance1 = findDistance(lca, node1, 0)\n",
    "    distance2 = findDistance(lca, node2, 0)\n",
    "\n",
    "    return distance1 + distance2\n",
    "\n",
    "\n",
    "values = [8, 3, 1, 6, 4, 7, 10, 14, 13]\n",
    "node1 = 6\n",
    "node2 = 14\n",
    "print(\"The distance between the two keys:\", distanceBetweenNodes(values, node1, node2))\n",
    "\n",
    "node1 = 3\n",
    "node2 = 4\n",
    "print(\"The distance between the two keys:\", distanceBetweenNodes(values, node1, node2))\n"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<aside>\n",
    "ðŸ’¡ Question-3:\n",
    "\n",
    "Write a program to convert a binary tree to a doubly linked list.\n",
    "```\n",
    "Input:\n",
    "\n",
    "        10\n",
    "\n",
    "       /   \\\n",
    "\n",
    "     5     20\n",
    "\n",
    "           /   \\\n",
    "\n",
    "        30     35\n",
    "\n",
    "Output:\n",
    "\n",
    "5 10 30 20 35\n",
    "```\n",
    "</aside>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "class TreeNode:\n",
    "    def __init__(self, val):\n",
    "        self.val = val\n",
    "        self.left = None\n",
    "        self.right = None\n",
    "\n",
    "\n",
    "class DoublyLinkedListNode:\n",
    "    def __init__(self, val):\n",
    "        self.val = val\n",
    "        self.prev = None\n",
    "        self.next = None\n",
    "\n",
    "\n",
    "def convertToDoublyLinkedList(root):\n",
    "    if root is None:\n",
    "        return None\n",
    "\n",
    "    # Initialize the previous pointer as None\n",
    "    prev = None\n",
    "\n",
    "    # Convert the left subtree to a doubly linked list\n",
    "    head = convertToDoublyLinkedList(root.left)\n",
    "\n",
    "    # Create a doubly linked list node for the current root\n",
    "    current = DoublyLinkedListNode(root.val)\n",
    "\n",
    "    # If the left subtree exists, update the links\n",
    "    if head is not None:\n",
    "        current.prev = head\n",
    "        head.next = current\n",
    "\n",
    "    # If there is a previous node, update the links\n",
    "    if prev is not None:\n",
    "        prev.next = current\n",
    "        current.prev = prev\n",
    "\n",
    "    # Update the previous node to the current node\n",
    "    prev = current\n",
    "\n",
    "    # Convert the right subtree to a doubly linked list\n",
    "    tail = convertToDoublyLinkedList(root.right)\n",
    "\n",
    "    # If the right subtree exists, update the links\n",
    "    if tail is not None:\n",
    "        tail.prev = current\n",
    "        current.next = tail\n",
    "\n",
    "    # Find the head of the doubly linked list\n",
    "    while head is not None and head.prev is not None:\n",
    "        head = head.prev\n",
    "\n",
    "    return head\n",
    "\n",
    "\n",
    "# Test case\n",
    "root = TreeNode(10)\n",
    "root.left = TreeNode(5)\n",
    "root.right = TreeNode(20)\n",
    "root.right.left = TreeNode(30)\n",
    "root.right.right = TreeNode(35)\n",
    "\n",
    "# Convert binary tree to doubly linked list\n",
    "head = convertToDoublyLinkedList(root)\n",
    "\n",
    "# Print the doubly linked list\n",
    "current = head\n",
    "while current is not None:\n",
    "    print(current.val, end=\" \")\n",
    "    current = current.next\n"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<aside>\n",
    "ðŸ’¡ Question-4:\n",
    "\n",
    "Write a program to connect nodes at the same level.\n",
    "```\n",
    "Input:\n",
    "\n",
    "        1\n",
    "\n",
    "      /   \\\n",
    "\n",
    "    2      3\n",
    "\n",
    "  /   \\   /   \\\n",
    "\n",
    "4     5 6    7\n",
    "\n",
    "Output:\n",
    "\n",
    "1 â†’ -1\n",
    "\n",
    "2 â†’ 3\n",
    "\n",
    "3 â†’ -1\n",
    "\n",
    "4 â†’ 5\n",
    "\n",
    "5 â†’ 6\n",
    "\n",
    "6 â†’ 7\n",
    "\n",
    "7 â†’ -1\n",
    "```\n",
    "\n",
    "</aside>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1 -> -1\n",
      "2 -> 3\n",
      "3 -> -1\n",
      "4 -> 5\n",
      "5 -> 6\n",
      "6 -> 7\n",
      "7 -> -1\n"
     ]
    }
   ],
   "source": [
    "class TreeNode:\n",
    "    def __init__(self, val):\n",
    "        self.val = val\n",
    "        self.left = None\n",
    "        self.right = None\n",
    "        self.next = None\n",
    "\n",
    "\n",
    "def connectNodesAtSameLevel(root):\n",
    "    if root is None:\n",
    "        return root\n",
    "\n",
    "    # Create a queue for level order traversal\n",
    "    queue = []\n",
    "    queue.append(root)\n",
    "\n",
    "    # Set the next pointer of the root node to None\n",
    "    root.next = None\n",
    "\n",
    "    # Perform level order traversal\n",
    "    while queue:\n",
    "        # Get the size of the current level\n",
    "        size = len(queue)\n",
    "\n",
    "        # Process all nodes at the current level\n",
    "        for i in range(size):\n",
    "            # Remove the front node from the queue\n",
    "            node = queue.pop(0)\n",
    "\n",
    "            # Set the next pointer of the current node\n",
    "            if i < size - 1:\n",
    "                node.next = queue[0]\n",
    "            else:\n",
    "                node.next = None\n",
    "\n",
    "            # Add the left and right children to the queue\n",
    "            if node.left:\n",
    "                queue.append(node.left)\n",
    "            if node.right:\n",
    "                queue.append(node.right)\n",
    "\n",
    "    return root\n",
    "\n",
    "\n",
    "# Test case\n",
    "root = TreeNode(1)\n",
    "root.left = TreeNode(2)\n",
    "root.right = TreeNode(3)\n",
    "root.left.left = TreeNode(4)\n",
    "root.left.right = TreeNode(5)\n",
    "root.right.left = TreeNode(6)\n",
    "root.right.right = TreeNode(7)\n",
    "\n",
    "# Connect nodes at the same level\n",
    "root = connectNodesAtSameLevel(root)\n",
    "\n",
    "# Print the next pointers\n",
    "current = root\n",
    "while current:\n",
    "    temp = current\n",
    "    while temp:\n",
    "        if temp.next:\n",
    "            print(temp.val, '->', temp.next.val)\n",
    "        else:\n",
    "            print(temp.val, '-> -1')\n",
    "        temp = temp.next\n",
    "    current = current.left\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.11"
  },
  "orig_nbformat": 4
 },
 "nbformat": 4,
 "nbformat_minor": 2
